# Архитектура Агента Генерации Мира

## Обзор

Система агентной генерации мира (World Generation Agent System) в TaleSpinner — это интеллектуальная многоагентная архитектура, которая использует LLM (Large Language Models) для создания детализированных игровых миров на основе пользовательского ввода. Система состоит из двух специализированных агентов, работающих в связке для анализа информации, сбора недостающих данных и генерации полноценного мира.

## Ключевые компоненты

### 1. **Analysis Agent** (`analysis.agent.ts`)

Агент анализа — это первая критическая часть системы, отвечающая за интерактивный сбор информации о мире.

#### Основные функции:
- **Анализ пользовательского ввода** — извлекает факты о мире из текста пользователя
- **Отслеживание прогресса** — ведёт список известной и недостающей информации
- **Генерация вопросов** — создаёт контекстуальные, креативные вопросы для заполнения пробелов
- **Определение готовности** — решает, когда собрано достаточно информации для генерации мира

#### Алгоритм работы:

```
1. Получить от пользователя текстовый ввод
2. Сравнить с текущей базой знаний (currentKnownInfo)
3. Извлечь новые факты из ввода
4. Определить недостающие категории информации:
   - Основная концепция и тон
   - География и локации
   - Фракции и политика
   - Расы и жители
   - История и хронология
   - Система магии/технологий
5. Если критическая информация отсутствует:
   → Сгенерировать ОДИН контекстуальный вопрос
6. Если пользователь сказал "удиви меня" или предоставил достаточно деталей:
   → Установить is_ready = true
7. Вернуть результат анализа
```

#### Структура промпта:

Агент анализа использует тщательно составленный промпт, который:
- Определяет роль агента как "эксперта по созданию миров"
- Предоставляет контекст (тип сеттинга, текущие знания)
- Даёт чёткие инструкции по извлечению и категоризации информации
- Требует генерировать креативные, специфические вопросы (не общие типа "Расскажи о фракциях")
- Использует примеры качественных вопросов на основе контекста

#### Формат ответа:

Агент возвращает структурированный JSON с использованием OpenAI Structured Output:

```typescript
{
  known_info: string[];          // Список извлечённых фактов
  missing_info: string[];        // Список недостающих категорий
  next_question: {               // Следующий вопрос или null
    id: string;
    text: string;
    category: string;
  } | null;
  is_ready: boolean;            // Готовность к генерации
}
```

### 2. **Generation Agent** (`generation.agent.ts`)

Агент генерации отвечает за создание полноценного описания мира на основе собранной информации.

#### Основные функции:
- **Синтез информации** — объединяет все собранные факты в связную картину
- **Заполнение пробелов** — креативно дополняет недостающие детали
- **Структурирование данных** — создаёт детализированные объекты для всех компонентов мира
- **Валидация** — проверяет согласованность и полноту генерируемых данных

#### Генерируемые сущности:

1. **Базовая информация**:
   - Название мира
   - Жанр
   - Тон/атмосфера
   - World Primer (общее описание)

2. **Фракции** (минимум 3):
   - Название и тип
   - Идеология и цели
   - Структура организации
   - Ключевые лидеры
   - Методы действия
   - Взаимоотношения с другими фракциями
   - Роль в конфликте
   - Ресурсы и влияние

3. **Локации** (минимум 3):
   - Название и тип
   - Внешний вид
   - История
   - Обитатели
   - Значимость
   - Особенности и секреты
   - Возможности для приключений

4. **Расы** (минимум 2):
   - Название
   - Описание
   - Связь с конфликтом
   - Особые способности
   - Социальная структура

5. **История** (минимум 3 события):
   - Название события
   - Временные рамки
   - Описание
   - Влияние на настоящее

6. **Система магии/технологий**:
   - Основы магии
   - Источники силы
   - Школы магии
   - Ограничения и цена
   - Отношение общества
   - Роль в конфликте
   - Артефакты и места силы

#### Промпт и стратегия генерации:

```
Задача: Создать детализированный RPG-мир
Вход: Собранная информация + Настройка сеттинга
Требования:
  - Быть креативным и последовательным
  - Заполнить пробелы логичными деталями
  - Соблюдать установленный тон
  - Генерировать увлекательный контент
```

#### Структурированный вывод:

Агент использует строгую JSON Schema для обеспечения качества и полноты данных:
- Все поля обязательны (`required`)
- Запрет дополнительных свойств (`additionalProperties: false`)
- Точное соответствие схеме Zod для валидации

### 3. **Agent World Service** (`agent-world.service.ts`)

Оркестрирующий сервис, управляющий жизненным циклом генерации мира и координирующий работу агентов.

#### Ключевые методы:

##### `startSession(setting: string)`
Инициализирует новую сессию генерации мира.

```typescript
1. Генерирует уникальный ID сессии (UUID)
2. Создаёт запись в таблице world_generation_sessions:
   - status: "collecting_info"
   - setting: тип сеттинга (например, "fantasy")
   - collected_info: пустой массив
3. Возвращает sessionId
```

##### `analyzeInput(sessionId: string, userInput: string)`
Обрабатывает каждый ввод пользователя через Analysis Agent.

```typescript
1. Загружает текущее состояние сессии из БД
2. Вызывает analysisAgent.analyze() с:
   - Новым пользовательским вводом
   - Текущей базой знаний
   - Типом сеттинга
3. Валидирует результат через AgentAnalysisSchema (Zod)
4. Объединяет новые факты с существующими:
   updatedKnownInfo = [...currentKnownInfo, ...analysis.known_info]
5. Обновляет сессию в БД
6. Возвращает результат анализа
```

##### `generateWorld(sessionId: string)`
Запускает процесс генерации полного описания мира.

```typescript
1. Загружает собранную информацию из сессии
2. Вызывает generationAgent.generate() с:
   - Всей collected_info
   - Типом сеттинга
3. Валидирует результат через WorldDataSchema (Zod)
4. Обновляет сессию:
   - generated_world: JSON с данными мира
   - status: "review"
5. Возвращает сгенерированные данные мира
```

##### `saveWorld(sessionId: string, worldData: any)`
Сохраняет отредактированный мир в основную таблицу.

```typescript
1. Валидирует worldData через WorldDataSchema
2. Генерирует UUID для мира
3. Сохраняет в таблицу worlds:
   - Базовые поля: name, genre, tone, description
   - data: полный JSON с детальными данными
4. Обновляет статус сессии на "completed"
5. Возвращает worldId
```

### 4. **LLM Service** (`llm.service.ts`)

Базовый сервис для взаимодействия с LLM через OpenRouter API.

#### Архитектурные паттерны:
- **Singleton** — единый экземпляр на всё приложение
- **Lazy initialization** — клиент создаётся при первом вызове
- **Конфигурация из файла** — API-ключи и модель загружаются из api-settings

#### Метод `call()`:

```typescript
Параметры:
  - messages: массив сообщений (chat completion)
  - responseFormat: JSON Schema для структурированного вывода
  - temperature: креативность (по умолчанию 0.7)

Процесс:
  1. Загрузить API-настройки
  2. Создать OpenAI-клиент с baseURL для OpenRouter
  3. Выполнить chat.completions.create()
  4. Если responseFormat = json_schema → распарсить JSON
  5. Вернуть результат
```

#### Обработка ошибок:
- Проверка наличия API-ключа
- Валидация наличия ответа от модели
- Логирование ошибок
- Прокидывание исключений выше

### 5. **Схемы данных** (`schemas/world.ts`)

Все данные валидируются через Zod-схемы, обеспечивая типобезопасность на уровне runtime.

#### Ключевые схемы:

```typescript
WorldDataSchema {
  name: string
  genre: string
  tone: string
  world_primer: string
  factions: Faction[]
  locations: Location[]
  races: Race[]
  history: TimelineEvent[]
  magic: MagicSystem
}

AgentAnalysisSchema {
  known_info: string[]
  missing_info: string[]
  next_question: AgentQuestion | null
  is_ready: boolean
}

SessionStatusSchema: "collecting_info" | "generating" | "review" | "completed"
```

## Полный поток работы

### Фаза 1: Инициализация

```
Пользователь → Frontend → POST /world-creation/agent/start
                          ↓
                   AgentWorldService.startSession()
                          ↓
                    world_generation_sessions [DB]
                          ↓
                   return { sessionId }
```

### Фаза 2: Сбор информации (итеративная)

```
Пользователь вводит описание → Frontend → POST /world-creation/agent/analyze
                                           ↓
                                  AgentWorldService.analyzeInput()
                                           ↓
                                  AnalysisAgent.analyze()
                                           ↓
                                      LLMService.call()
                                           ↓
                                      OpenRouter API
                                           ↓
                                  {
                                    known_info: ["Мир парящих островов"...],
                                    missing_info: ["Фракции", "Магия"],
                                    next_question: {
                                      text: "Кто контролирует торговые пути?"
                                    },
                                    is_ready: false
                                  }
                                           ↓
                            Обновление collected_info в БД
                                           ↓
                            Отображение вопроса пользователю
                                           ↓
                          Пользователь отвечает → повтор цикла
```

**Цикл продолжается до тех пор, пока:**
- `is_ready = true` (достаточно информации)
- Пользователь говорит "удиви меня" / "придумай сам"

### Фаза 3: Генерация мира

```
Analysis Agent устанавливает is_ready = true
                          ↓
            POST /world-creation/agent/generate
                          ↓
            AgentWorldService.generateWorld()
                          ↓
            GenerationAgent.generate()
                          ↓
            LLMService.call() с полной JSON Schema
                          ↓
                 OpenRouter API
                          ↓
            {
              name: "Империя Парящих Островов",
              factions: [...],
              locations: [...],
              races: [...],
              history: [...],
              magic: {...}
            }
                          ↓
          Валидация через WorldDataSchema
                          ↓
          Сохранение в generated_world [DB]
                          ↓
          status → "review"
                          ↓
          Отображение в UI для редактирования
```

### Фаза 4: Редактирование и сохранение

```
Пользователь редактирует данные в UI
                          ↓
            Нажимает "Сохранить мир"
                          ↓
          POST /world-creation/agent/save
                          ↓
        AgentWorldService.saveWorld()
                          ↓
    Валидация через WorldDataSchema
                          ↓
    INSERT INTO worlds (id, name, genre, tone, description, data)
                          ↓
    Обновление статуса сессии → "completed"
                          ↓
          return { worldId }
                          ↓
    Переход к использованию мира в приложении
```

## API Endpoints

### `/world-creation/agent/start`
**Метод:** POST  
**Тело запроса:**
```json
{
  "setting": "fantasy"
}
```
**Ответ:**
```json
{
  "sessionId": "uuid-v4"
}
```

### `/world-creation/agent/analyze`
**Метод:** POST  
**Тело запроса:**
```json
{
  "sessionId": "uuid",
  "userInput": "Мир состоит из парящих островов..."
}
```
**Ответ:**
```json
{
  "known_info": ["Мир парящих островов", ...],
  "missing_info": ["Фракции", "Система магии"],
  "next_question": {
    "id": "uuid",
    "text": "Кто контролирует торговые пути между островами?",
    "category": "Factions"
  },
  "is_ready": false
}
```

### `/world-creation/agent/generate`
**Метод:** POST  
**Тело запроса:**
```json
{
  "sessionId": "uuid"
}
```
**Ответ:** Полный объект `WorldData`

### `/world-creation/agent/save`
**Метод:** POST  
**Тело запроса:**
```json
{
  "sessionId": "uuid",
  "worldData": { /* WorldData object */ }
}
```
**Ответ:**
```json
{
  "worldId": "uuid"
}
```

## Компонент интерфейса: AgentChat

### Архитектура компонента

**Файл:** `frontend/src/components/world-creation/wizard/steps/AgentChat.tsx`

#### Состояние компонента:

```typescript
- messages: Message[]          // История диалога
- input: string                // Текущий ввод пользователя
- loading: boolean             // Состояние загрузки
- analysis: AgentAnalysis      // Последний результат анализа
- error: string | null         // Состояние ошибки
```

#### Основные функции:

##### `analyze(userInput: string)`
```typescript
1. Устанавливает loading = true
2. Отправляет POST /world-creation/agent/analyze
3. Получает AgentAnalysis
4. Если есть next_question:
   → Добавляет вопрос в messages
5. Если is_ready = true:
   → Сообщает о готовности
   → Вызывает generate()
6. Обрабатывает ошибки
7. Устанавливает loading = false
```

##### `generate()`
```typescript
1. Устанавливает loading = true
2. Отправляет POST /world-creation/agent/generate
3. Получает WorldData
4. Вызывает onComplete(worldData)
5. Переход к следующему шагу визарда
```

#### UI-структура:

**Левая панель (Conversation):**
- История сообщений (пользователь + агент)
- Поле ввода текста
- Кнопка отправки
- Индикатор загрузки

**Правая панель (Knowledge Base):**
- **Known Facts** — список собранных фактов (Chips)
- **Missing Info** — недостающие категории (Warning Chips)
- **Generate Now** — кнопка ручной генерации (если is_ready = true)

#### Логика взаимодействия:

```typescript
useEffect(() => {
  // При монтировании компонента
  analyze(initialInput);  // Анализируем начальный ввод
}, []);

handleSend() {
  if (!input.trim()) return;
  setMessages([...messages, { role: "user", text: input }]);
  analyze(input);         // Отправляем на анализ
  setInput("");           // Очищаем поле
}
```

## Управление базой данных

### Таблица: `world_generation_sessions`

```sql
Columns:
  - id: UUID (primary key)
  - status: SessionStatus (collecting_info | generating | review | completed)
  - setting: string (например, "fantasy")
  - collected_info: JSON (массив строк)
  - user_input: string (последний ввод)
  - generated_world: JSON (результат генерации)
  - created_at: timestamp
```

### Таблица: `worlds`

```sql
Columns:
  - id: UUID (primary key)
  - name: string
  - genre: string
  - tone: string
  - description: string (world_primer)
  - data: JSON (полные данные WorldData)
  - created_at: timestamp
```

## Валидация и типобезопасность

### Два уровня валидации:

1. **Compile-time (TypeScript)**
   - Статические типы, генерируемые из Zod-схем
   - Проверка на этапе разработки

2. **Runtime (Zod)**
   - Валидация данных от API
   - Валидация данных от LLM
   - Валидация перед сохранением в БД

### Схема валидации:

```
LLM Response → JSON.parse() → Zod Schema.parse() → Validated TypeScript Type
                                     ↓
                              Если невалидно → Error
                                     ↓
                              Логирование и возврат ошибки
```

## Обработка ошибок

### Уровень агентов:
```typescript
try {
  const result = await this.llm.call({...});
  return Schema.parse(result);
} catch (error) {
  console.error("Failed to ...", error);
  throw new Error("User-friendly message");
}
```

### Уровень сервиса:
```typescript
try {
  // Бизнес-логика
} catch (error) {
  console.error("Detailed error:", error);
  throw new Error("Failed to ... ");
}
```

### Уровень API:
```typescript
try {
  const result = await service.method();
  res.json(result);
} catch (error) {
  // Express error handler перехватывает и возвращает 500
}
```

### Уровень UI:
```typescript
try {
  const res = await fetch(...);
  if (!res.ok) throw new Error("Failed to ...");
  // Обработка данных
} catch (err) {
  setError(err.message);
  onError?.(err.message);
}
```

## Оптимизации и best practices

### 1. **Structured Output (JSON Schema)**
Использование `response_format` с `json_schema`:
- Гарантирует корректный формат ответа
- Снижает количество ошибок парсинга
- Обеспечивает согласованность данных

### 2. **Strict Mode**
```typescript
json_schema: {
  strict: true,
  schema: {...}
}
```
- Запрет дополнительных полей
- Требование всех указанных полей
- Более предсказуемые результаты

### 3. **Итеративный сбор информации**
- Один вопрос за раз
- Контекстуальные вопросы на основе уже собранной информации
- Избегание перегрузки пользователя

### 4. **Валидация на каждом этапе**
- После LLM вызова
- Перед сохранением в БД
- При передаче между компонентами

### 5. **Singleton для сервисов**
- LLMService — единый экземпляр
- DbService — единый экземпляр
- Экономия ресурсов

### 6. **Разделение ответственности**
- **Analysis Agent** — сбор информации
- **Generation Agent** — создание контента
- **AgentWorldService** — оркестрация
- **LLMService** — абстракция API

## Возможные улучшения

### Краткосрочные:
1. **Streaming responses** — потоковая генерация для лучшего UX
2. **Кэширование промежуточных результатов** — снижение количества API-вызовов
3. **Поддержка отмены генерации** — возможность прервать процесс
4. **История версий** — отслеживание изменений мира

### Долгосрочные:
1. **Мультимодальность** — загрузка изображений для визуального контекста
2. **Коллаборативная генерация** — несколько пользователей одновременно
3. **AI-ассистент для редактирования** — помощь в доработке сгенерированного контента
4. **Экспорт в различные форматы** — PDF, JSON, markdown, интеграция с VTT-платформами

## Заключение

Система агентной генерации мира в TaleSpinner представляет собой сложную многокомпонентную архитектуру, использующую современные подходы к работе с LLM:

- **Структурированный вывод** для надёжности
- **Многоагентная система** для разделения задач
- **Итеративный диалог** для качественного сбора данных
- **Полная типобезопасность** от TypeScript + Zod
- **Чёткое разделение слоёв** (API, сервисы, агенты, UI)

Эта архитектура обеспечивает создание детализированных, согласованных и увлекательных игровых миров с минимальным участием пользователя, при этом оставляя за ним полный контроль над финальным результатом.
